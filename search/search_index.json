{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"introduction | detailed information | Configure & Build | API description | Custom log formatting Welcome to g3log G3log is an asynchronous logger with three main features: 1. Intuitive LOG(...) API 2. Design-by-contract CHECK(...) functionality 3. Fatal crash handling for graceful shutdown of the logged process without loosing any log details up to the point of the crash. The super quick introduction to g3log can be seen in the steps 1 - 9 below. For more in-depth information please see the full usage description in g3log.md . The internal API for more advanced integration with g3log can be accessed in API.md 1. Easy usage in files Avoid deep dependency injection complexity and instead get access to the logger as easy as #include <g3log/g3log.hpp> 2. Access to streaming and print_f log call syntax Both streaming syntax LOG and print_f LOGF syntax are available. LOGF(INFO, \"Hi log %d\", 123); LOG(INF) << \"Hi log \" << 123; 3. Conditional logging LOG_IF(INFO, (1 < 2)) << \"If true this message will be logged\"; LOGF_IF(INFO, (1 < 2), \"If true, then this %s will be logged\", \"message\"); 4. Design-by-contract framework CHECK(less != more); // not fatal CHECK_F(less > more, \"CHECK(false) will trigger a fatal message\") 5. Handling of fatal By default g3log will capture fatal events such as LOG(FATAL) , CHECK(false) and otherwise fatal signals such as: SIGABRT SIGFPE SIGILL SIGSEGV SIGTERM When a fatal event happens the not-yet written log activity will be flushed to the logging sinks. Only when all logging activity up to the point of the fatal event has happend, will g3log allow the fatal event to proceed and exit the process. If object symbols are available the fatal handler will attempt to push the stacktrace up to the fatal reason to the logging sink. 5b. Overriding and customization of fatal event handling For overriding fatal error handling to use your own, or to add code hooks that you want to execute please see the API.md doc. 6. Default and Custom logging levels The default logging levels are DEBUG , INFO , WARNING and FATAL . You can define your own logging levels or completely replace the logging levels. Ref: API.md 7. Log filtering Log filtering is handled in g3log if dynamic logging levels are enabled in the configuration. See the API.md for information. Log filtering can also be handled through the sink as can be seen in github/Kjellod/g3sinks 8. 3rd party and custom logging sinks The default logging sink has no external 3rd party dependencies. For more logging sinks please see github/Kjellod/g3sinks log rotate log to syslog log to colored terminal output log rotate with filter See the API.md for more information about the simple steps to creating your own logging sink. 9. Log instantiation With the default application name left as is (i.e. \"g3log\") a creation of the logger could look something like this: const std::string directory = \"./\"; const std::string name = \"TestLogFile\"; auto worker = g3::LogWorker::createLogWorker(); auto handle = worker->addDefaultLogger(name, directory); The resulting filename would be something like: ./TestLogFile.g3log.20160217-001406.log Performance G3log aims to keep all background logging to sinks with as little log overhead as possible to the logging sink and with as small \"worst case latency\" as possible. For this reason g3log is a good logger for many systems that deal with critical tasks. Depending on platform the average logging overhead will differ. On my 2010 laptop the average call, when doing extreme performance testing, will be about ~2 us. The worst case latency is kept stable with no extreme peaks, in spite of any sudden extreme pressure. I have a blog post regarding comparing worst case latency for g3log and other loggers which might be of interest. You can find it here: https://kjellkod.wordpress.com/2015/06/30/the-worlds-fastest-logger-vs-g3log/ Continuos Integration The g3log repository is evaluating both github actions and CircleCI for executing test coverage, installation and document generation. For windows the repo is still relying on appveyor. In case you want to look into change any of these setups the following files are the ones of interest. 1. appveyor --> g3log/appveyor.yml 2. circleCI --> g3log/.circleci/config.yml 3. github actions --> g3log/.github/workflows/*.yml Feedback If you like this logger (or not) it would be nice with some feedback. That way I can improve g3log and it is always nice to hear when and how someone is using it. If you have ANY questions or problems please do not hesitate in contacting me at Hedstrom @ Kjellod. cc Say Thanks This logger is available for free and all of its source code is public domain. A great way of saying thanks is to send a donation. It would go a long way not only to show your support but also to boost continued development. $5 for a cup of coffee $25 for a late evening coding with takeout Cheers Kjell (a.k.a. KjellKod) introduction | detailed information | Configure & Build | API description | Custom log formatting","title":"Introduction to G3log"},{"location":"#welcome-to-g3log","text":"G3log is an asynchronous logger with three main features: 1. Intuitive LOG(...) API 2. Design-by-contract CHECK(...) functionality 3. Fatal crash handling for graceful shutdown of the logged process without loosing any log details up to the point of the crash. The super quick introduction to g3log can be seen in the steps 1 - 9 below. For more in-depth information please see the full usage description in g3log.md . The internal API for more advanced integration with g3log can be accessed in API.md","title":"Welcome to g3log"},{"location":"#1-easy-usage-in-files","text":"Avoid deep dependency injection complexity and instead get access to the logger as easy as #include <g3log/g3log.hpp>","title":"1. Easy usage in files"},{"location":"#2-access-to-streaming-and-print_f-log-call-syntax","text":"Both streaming syntax LOG and print_f LOGF syntax are available. LOGF(INFO, \"Hi log %d\", 123); LOG(INF) << \"Hi log \" << 123;","title":"2. Access to streaming and print_f log call syntax"},{"location":"#3-conditional-logging","text":"LOG_IF(INFO, (1 < 2)) << \"If true this message will be logged\"; LOGF_IF(INFO, (1 < 2), \"If true, then this %s will be logged\", \"message\");","title":"3. Conditional logging"},{"location":"#4-design-by-contract-framework","text":"CHECK(less != more); // not fatal CHECK_F(less > more, \"CHECK(false) will trigger a fatal message\")","title":"4. Design-by-contract framework"},{"location":"#5-handling-of-fatal","text":"By default g3log will capture fatal events such as LOG(FATAL) , CHECK(false) and otherwise fatal signals such as: SIGABRT SIGFPE SIGILL SIGSEGV SIGTERM When a fatal event happens the not-yet written log activity will be flushed to the logging sinks. Only when all logging activity up to the point of the fatal event has happend, will g3log allow the fatal event to proceed and exit the process. If object symbols are available the fatal handler will attempt to push the stacktrace up to the fatal reason to the logging sink.","title":"5. Handling of fatal"},{"location":"#5b-overriding-and-customization-of-fatal-event-handling","text":"For overriding fatal error handling to use your own, or to add code hooks that you want to execute please see the API.md doc.","title":"5b. Overriding and customization of fatal event handling"},{"location":"#6-default-and-custom-logging-levels","text":"The default logging levels are DEBUG , INFO , WARNING and FATAL . You can define your own logging levels or completely replace the logging levels. Ref: API.md","title":"6. Default and Custom logging levels"},{"location":"#7-log-filtering","text":"Log filtering is handled in g3log if dynamic logging levels are enabled in the configuration. See the API.md for information. Log filtering can also be handled through the sink as can be seen in github/Kjellod/g3sinks","title":"7. Log filtering"},{"location":"#8-3rd-party-and-custom-logging-sinks","text":"The default logging sink has no external 3rd party dependencies. For more logging sinks please see github/Kjellod/g3sinks log rotate log to syslog log to colored terminal output log rotate with filter See the API.md for more information about the simple steps to creating your own logging sink.","title":"8. 3rd party and custom logging sinks"},{"location":"#9-log-instantiation","text":"With the default application name left as is (i.e. \"g3log\") a creation of the logger could look something like this: const std::string directory = \"./\"; const std::string name = \"TestLogFile\"; auto worker = g3::LogWorker::createLogWorker(); auto handle = worker->addDefaultLogger(name, directory); The resulting filename would be something like: ./TestLogFile.g3log.20160217-001406.log","title":"9. Log instantiation"},{"location":"#performance","text":"G3log aims to keep all background logging to sinks with as little log overhead as possible to the logging sink and with as small \"worst case latency\" as possible. For this reason g3log is a good logger for many systems that deal with critical tasks. Depending on platform the average logging overhead will differ. On my 2010 laptop the average call, when doing extreme performance testing, will be about ~2 us. The worst case latency is kept stable with no extreme peaks, in spite of any sudden extreme pressure. I have a blog post regarding comparing worst case latency for g3log and other loggers which might be of interest. You can find it here: https://kjellkod.wordpress.com/2015/06/30/the-worlds-fastest-logger-vs-g3log/","title":"Performance"},{"location":"#continuos-integration","text":"The g3log repository is evaluating both github actions and CircleCI for executing test coverage, installation and document generation. For windows the repo is still relying on appveyor. In case you want to look into change any of these setups the following files are the ones of interest. 1. appveyor --> g3log/appveyor.yml 2. circleCI --> g3log/.circleci/config.yml 3. github actions --> g3log/.github/workflows/*.yml","title":"Continuos Integration"},{"location":"#feedback","text":"If you like this logger (or not) it would be nice with some feedback. That way I can improve g3log and it is always nice to hear when and how someone is using it. If you have ANY questions or problems please do not hesitate in contacting me at Hedstrom @ Kjellod. cc","title":"Feedback"},{"location":"#say-thanks","text":"This logger is available for free and all of its source code is public domain. A great way of saying thanks is to send a donation. It would go a long way not only to show your support but also to boost continued development. $5 for a cup of coffee $25 for a late evening coding with takeout Cheers Kjell (a.k.a. KjellKod) introduction | detailed information | Configure & Build | API description | Custom log formatting","title":"Say Thanks"},{"location":"API/","text":"introduction | detailed information | Configure & Build | API description | Custom log formatting API description Most of the API that you need for using g3log is described in this readme. For more API documentation and examples please continue to read the API readme . Examples of what you will find here are: Logging API: LOG calls LOG calls can follow streaming LOG(INFO) << \"some text\" or printf-like syntax LOGF(WARNING, \"some number %d\", 123); Conditional logging is made with LOG_IF(INFO, <boolean-expression>) << \" some text\" or LOGF_IF(WARNING, <boolean-expression>) << \" some text\". Only if the expressions evaluates to true will the logging take place. Example: LOG_IF(INFO, 1 != 200) << \" some text\"; or LOG_IF(FATAL, SomeFunctionCall()) << \" some text\"; A call using FATAL logging level, such as the LOG_IF(FATAL,...) example above, will after logging the message at FATAL level also kill the process. It is essentially the same as a CHECK(<boolea-expression>) << ... with the difference that the CHECK(<boolean-expression) triggers when the expression evaluates to false . Contract API: CHECK calls The contract API follows closely the logging API with CHECK(<boolean-expression>) << ... for streaming or (*) CHECKF(<boolean-expression>, ...); for printf-style. If the <boolean-expression> evaluates to false then the the message for the failed contract will be logged in FIFO order with previously made messages. The process will then shut down after the message is sent to the sinks and the sinks have dealt with the fatal contract message. (* * CHECK_F(<boolean-expression>, ...); was the the previous API for printf-like CHECK. It is still kept for backwards compatability but is exactly the same as CHECKF *) Logging levels The default logging levels are DEBUG , INFO , WARNING and FATAL (see FATAL usage above ). The logging levels are defined in loglevels.hpp . For some windows framework there is a clash with the DEBUG logging level. One of the CMake Build options can be used to then change offending default level from DEBUG TO DBUG . CMake option: (default OFF) cmake -DCHANGE_G3LOG_DEBUG_TO_DBUG=ON .. ### disable/enabled levels at runtime Logging levels can be disabled at runtime. The logic for this happens in loglevels.hpp , loglevels.cpp and g3log.hpp . There is a cmake option to enable the dynamic enable/disable of levels. When the option is enabled there will be a slight runtime overhead for each LOG call when the enable/disable status is checked. For most intent and purposes this runtime overhead is negligable. There is no runtime overhead for internally checking if a level is enabled//disabled if the cmake option is turned off. If the dynamic logging cmake option is turned off then all logging levels are enabled. CMake option: (default OFF) cmake -DUSE_DYNAMIC_LOGGING_LEVELS=ON .. ### custom logging levels Custom logging levels can be created and used. When defining a custom logging level you set the value for it as well as the text for it. You can re-use values for other levels such as INFO , WARNING etc or have your own values. Any value with equal or higher value than the FATAL value will be considered a FATAL logging level. To keep in mind when adding your own custom levels. 1. If the cmake option G3_DYNAMIC_LOGGING is enabled then you must use g3::only_change_at_initialization::addLogLevel(...) to give g3log a record of your logging level and if it is an enabled or disbled logging level. 1. If the cmake G3_DYNAMIC_LOGGING is turned OFF, then giving g3log a record of your logging level with 'addLogLevel(...) is not needed since no \"disbled/enabled\" check will happen - all logging levels will be considered enabled. Example: ```cpp // In CustomLoggingLevels.hpp #include // all values with a + 1 higher than their closest equivalet // they could really have the same value as well. const LEVELS FYI {DEBUG.value + 1, {\"For Your Information\"}}; const LEVELS CUSTOM {INFO.value + 1, {\"CUSTOM\"}}; const LEVELS SEVERE {WARNING.value +1, {\"SEVERE\"}}; const LEVELS DEADLY {FATAL.value + 1, {\"DEADLY\"}}; ``` More examples can be viwed in the unit tests . Sink creation and utilization The default sink for g3log is the one as used in g2log. It is a simple file sink with a limited API. The details for the default file sink can be found in filesink.hpp , filesink.cpp , filesinkhelper.ipp More sinks can be found at g3sinks (log rotate, log rotate with filtering on levels) A logging sink is not required to be a subclass of a specific type. The only requirement of a logging sink is that it can receive a logging message of Using the default sink Sink creation is defined in logworker.hpp and used in logworker.cpp . For in-depth knowlege regarding sink implementation details you can look at sinkhandle.hpp and sinkwrapper.hpp std::unique_ptr<FileSinkHandle> addDefaultLogger( const std::string& log_prefix , const std::string& log_directory , const std::string& default_id = \"g3log\"); With the default id left as is (i.e. \"g3log\") a creation of the logger in the unit test \"test_filechange\" would look like this const std::string directory = \"./\"; const std::string name = \"(ReplaceLogFile)\"; auto worker = g3::LogWorker::createLogWorker(); auto handle = worker->addDefaultLogger(name, directory); The resulting filename would be something like: ./(ReplaceLogFile).g3log.20160217-001406.log Designate the sink function's log entry receving function The default log formatting look can be overriden by any sink. If the sink receiving function calls toString() then the default log formatting will be used. If the sink receiving function calls toString(&XFunc) then the XFunc will be used instead (see LogMessage.h/cpp for code details if it is not clear). ( XFunc is a place holder for your formatting function of choice). The API for the function-ptr to pass in is std::string (*) (const LogMessage&) or for short as defined in LogMessage.h using LogDetailsFunc = std::string (*) (const LogMessage&); Log format customization Please see API_custom_formatting.md LOG flushing The default file sink will flush each log entry as it comes in. For different flushing policies please take a look at g3sinks logrotate and LogRotateWithFilters . At shutdown all enqueued logs will be flushed to the sink. At a discovered fatal event (SIGSEGV et.al) all enqueued logs will be flushed to the sink. A programmatically triggered abrupt process exit such as a call to exit(0) will of course not get the enqueued log entries flushed. Similary a bug that does not trigger a fatal signal but a process exit will also not get the enqueued log entries flushed. G3log can catch several fatal crashes and it deals well with RAII exits but magic is so far out of its' reach. G3log and Sink Usage Code Example Example usage where a logrotate sink (g3sinks) is added. In the example it is shown how the logrotate API is called. The logrotate limit is changed from the default to instead be 10MB. The limit is changed by calling the sink handler which passes the function call through to the actual logrotate sink object. // main.cpp #include <g3log/g3log.hpp> #include <g3log/logworker.h> #include <g3sinks/LogRotate.h> #include <memory> int main(int argc, char**argv) { using namespace g3; std::unique_ptr<LogWorker> logworker{ LogWorker::createLogWorker() }; auto sinkHandle = logworker->addSink(std::make_unique<LogRotate>(), &LogRotate::save); // initialize the logger before it can receive LOG calls initializeLogging(logworker.get()); // You can call in a thread safe manner public functions on the logrotate sink // The call is asynchronously executed on your custom sink. const int k10MBInBytes = 10 * 1024 * 1024; std::future<void> received = sinkHandle->call(&LogRotate::setMaxLogSize, k10MBInBytes); // Run the main part of the application. This can be anything of course, in this example // we'll call it \"RunApplication\". Once this call exits we are in shutdown mode RunApplication(); // If the LogWorker is initialized then at scope exit the g3::shutDownLogging() will be // called automatically. // // This is important since it protects from LOG calls from static or other entities that will go out of // scope at a later time. // // It can also be called manually if for some reason your setup is different then the one highlighted in // this example g3::shutDownLogging(); } Dynamic Message Sizing The default build uses a fixed size buffer for formatting messages. The size of this buffer is 2048 bytes. If an incoming message results in a formatted message that is greater than 2048 bytes, it will be bound to 2048 bytes and will have the string [...truncated...] appended to the end of the bound message. There are cases where one would like to dynamically change the size at runtime. For example, when debugging payloads for a server, it may be desirable to handle larger message sizes in order to examine the whole payload. Rather than forcing the developer to rebuild the server, dynamic message sizing could be used along with a config file which defines the message size at runtime. This feature supported as a CMake option: CMake option: (default OFF) cmake -DUSE_G3_DYNAMIC_MAX_MESSAGE_SIZE=ON .. The following is an example of changing the size for the message. g3::only_change_at_initialization::setMaxMessageSize(10000); Fatal handling The default behaviour for G3log is to catch several fatal events before they force the process to exit. After catching a fatal event a stack dump is generated and all log entries, up to the point of the stack dump are together with the dump flushed to the sink(s). Linux/*nix The default fatal handling on Linux deals with fatal signals. At the time of writing these signals were SIGABRT, SIGFPE, SIGILL, SIGSEGV, SIGTERM . The Linux fatal handling is handled in crashhandler.hpp and crashhandler_unix.cpp A signal that commonly is associated with voluntarily process exit is SIGINT (ctrl + c) G3log does not deal with it. The fatal signals can be disabled or changed/added . An example of a Linux stackdump as shown in the output from the fatal example g3log-FATAL-sigsegv . ``` * FATAL SIGNAL RECEIVED * \"Received fatal signal: SIGSEGV(11) PID: 6571 ***** SIGNAL SIGSEGV(11) ******* STACKDUMP ******* stack dump [1] ./g3log-FATAL-sigsegv() [0x42a500] stack dump [2] /lib/x86_64-linux-gnu/libpthread.so.0+0x10340 [0x7f83636d5340] stack dump [3] ./g3log-FATAL-sigsegv : example_fatal::tryToKillWithAccessingIllegalPointer(std::unique_ptr<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::default_delete<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >)+0x119 [0x4107b9] stack dump [4] ./g3log-FATAL-sigsegvmain+0xdec [0x40e51c] stack dump [5] /lib/x86_64-linux-gnu/libc.so.6__libc_start_main+0xf5 [0x7f8363321ec5] stack dump [6] ./g3log-FATAL-sigsegv() [0x40ffa2] Exiting after fatal event (FATAL_SIGNAL). Fatal type: SIGSEGV Log content flushed sucessfully to sink \" g3log g3FileSink shutdown at: 16:33:18 ``` Custom fatal handling - override defaults By default the fatal signals are defined in https://github.com/KjellKod/g3log/tree/master/src/g3log.cpp as SIGABRT SIGFPE SIGILL SIGSEGV SIGTERM If you want to define your own set of fatal signals, override the default ones, then this can be done as shown in src/g3log/crashhandler.hpp cpp // Example when SIGTERM is skipped due to ZMQ usage g3::overrideSetupSignals({ {SIGABRT, \"SIGABRT\"}, {SIGFPE, \"SIGFPE\"}, {SIGILL, \"SIGILL\"}, {SIGSEGV, \"SIGSEGV\"}}); Pre fatal hook You can define a custom call back function that will be called before the fatal signal handling re-emits the fatal signal. See src/g3log/g3log.hpp for details. // Example of how to enforce important shutdown cleanup even in the event of a fatal crash: g3::setFatalPreLoggingHook([]{ cleanup(); }); Disable fatal handling Fatal signal handling can be disabled with a CMake option: ENABLE_FATAL_SIGNALHANDLING . See Options.cmake for more details PID1 Fatal Signal Recommendations If you are using g3log on a PID1 process then you absolutely should provide your own signal handling (ref: issue 269 ) as g3log re-emits the fatal signal after it has restored the previous signal handler for that signal. PID1 processed do not shutdown the process for a normal fatal signal so the choice to exit the PID1 process after such a signal must be taken by the coder - not by g3log. Windows Windows fatal handling also deals with fatal signals just like Linux. In addition to fatal signals it also deals with unhandled exceptions, vectored exceptions. Windows fatal handling is handled in crashhandler.hpp , crashhandler_windows.cpp , stacktrace_windows.hpp , stacktrace_windows.cpp An example of a Windows stackdump as shown in the output from the fatal example g3log-FATAL-sigsegv . introduction | detailed information | Configure & Build | API description | Custom log formatting","title":"API description"},{"location":"API/#api-description","text":"Most of the API that you need for using g3log is described in this readme. For more API documentation and examples please continue to read the API readme . Examples of what you will find here are:","title":"API description"},{"location":"API/#logging-api-log-calls","text":"LOG calls can follow streaming LOG(INFO) << \"some text\" or printf-like syntax LOGF(WARNING, \"some number %d\", 123); Conditional logging is made with LOG_IF(INFO, <boolean-expression>) << \" some text\" or LOGF_IF(WARNING, <boolean-expression>) << \" some text\". Only if the expressions evaluates to true will the logging take place. Example: LOG_IF(INFO, 1 != 200) << \" some text\"; or LOG_IF(FATAL, SomeFunctionCall()) << \" some text\"; A call using FATAL logging level, such as the LOG_IF(FATAL,...) example above, will after logging the message at FATAL level also kill the process. It is essentially the same as a CHECK(<boolea-expression>) << ... with the difference that the CHECK(<boolean-expression) triggers when the expression evaluates to false .","title":"Logging API: LOG calls"},{"location":"API/#contract-api-check-calls","text":"The contract API follows closely the logging API with CHECK(<boolean-expression>) << ... for streaming or (*) CHECKF(<boolean-expression>, ...); for printf-style. If the <boolean-expression> evaluates to false then the the message for the failed contract will be logged in FIFO order with previously made messages. The process will then shut down after the message is sent to the sinks and the sinks have dealt with the fatal contract message. (* * CHECK_F(<boolean-expression>, ...); was the the previous API for printf-like CHECK. It is still kept for backwards compatability but is exactly the same as CHECKF *)","title":"Contract API: CHECK calls"},{"location":"API/#logging-levels","text":"The default logging levels are DEBUG , INFO , WARNING and FATAL (see FATAL usage above ). The logging levels are defined in loglevels.hpp . For some windows framework there is a clash with the DEBUG logging level. One of the CMake Build options can be used to then change offending default level from DEBUG TO DBUG . CMake option: (default OFF) cmake -DCHANGE_G3LOG_DEBUG_TO_DBUG=ON .. ### disable/enabled levels at runtime Logging levels can be disabled at runtime. The logic for this happens in loglevels.hpp , loglevels.cpp and g3log.hpp . There is a cmake option to enable the dynamic enable/disable of levels. When the option is enabled there will be a slight runtime overhead for each LOG call when the enable/disable status is checked. For most intent and purposes this runtime overhead is negligable. There is no runtime overhead for internally checking if a level is enabled//disabled if the cmake option is turned off. If the dynamic logging cmake option is turned off then all logging levels are enabled. CMake option: (default OFF) cmake -DUSE_DYNAMIC_LOGGING_LEVELS=ON .. ### custom logging levels Custom logging levels can be created and used. When defining a custom logging level you set the value for it as well as the text for it. You can re-use values for other levels such as INFO , WARNING etc or have your own values. Any value with equal or higher value than the FATAL value will be considered a FATAL logging level. To keep in mind when adding your own custom levels. 1. If the cmake option G3_DYNAMIC_LOGGING is enabled then you must use g3::only_change_at_initialization::addLogLevel(...) to give g3log a record of your logging level and if it is an enabled or disbled logging level. 1. If the cmake G3_DYNAMIC_LOGGING is turned OFF, then giving g3log a record of your logging level with 'addLogLevel(...) is not needed since no \"disbled/enabled\" check will happen - all logging levels will be considered enabled. Example: ```cpp // In CustomLoggingLevels.hpp #include // all values with a + 1 higher than their closest equivalet // they could really have the same value as well. const LEVELS FYI {DEBUG.value + 1, {\"For Your Information\"}}; const LEVELS CUSTOM {INFO.value + 1, {\"CUSTOM\"}}; const LEVELS SEVERE {WARNING.value +1, {\"SEVERE\"}}; const LEVELS DEADLY {FATAL.value + 1, {\"DEADLY\"}}; ``` More examples can be viwed in the unit tests .","title":"Logging levels"},{"location":"API/#sink-creation-and-utilization","text":"The default sink for g3log is the one as used in g2log. It is a simple file sink with a limited API. The details for the default file sink can be found in filesink.hpp , filesink.cpp , filesinkhelper.ipp More sinks can be found at g3sinks (log rotate, log rotate with filtering on levels) A logging sink is not required to be a subclass of a specific type. The only requirement of a logging sink is that it can receive a logging message of","title":"Sink creation and utilization"},{"location":"API/#using-the-default-sink","text":"Sink creation is defined in logworker.hpp and used in logworker.cpp . For in-depth knowlege regarding sink implementation details you can look at sinkhandle.hpp and sinkwrapper.hpp std::unique_ptr<FileSinkHandle> addDefaultLogger( const std::string& log_prefix , const std::string& log_directory , const std::string& default_id = \"g3log\"); With the default id left as is (i.e. \"g3log\") a creation of the logger in the unit test \"test_filechange\" would look like this const std::string directory = \"./\"; const std::string name = \"(ReplaceLogFile)\"; auto worker = g3::LogWorker::createLogWorker(); auto handle = worker->addDefaultLogger(name, directory); The resulting filename would be something like: ./(ReplaceLogFile).g3log.20160217-001406.log","title":"Using the default sink"},{"location":"API/#designate-the-sink-functions-log-entry-receving-function","text":"The default log formatting look can be overriden by any sink. If the sink receiving function calls toString() then the default log formatting will be used. If the sink receiving function calls toString(&XFunc) then the XFunc will be used instead (see LogMessage.h/cpp for code details if it is not clear). ( XFunc is a place holder for your formatting function of choice). The API for the function-ptr to pass in is std::string (*) (const LogMessage&) or for short as defined in LogMessage.h using LogDetailsFunc = std::string (*) (const LogMessage&);","title":"Designate the sink function's log entry receving function"},{"location":"API/#log-format-customization","text":"Please see API_custom_formatting.md","title":"Log format customization"},{"location":"API/#log-flushing","text":"The default file sink will flush each log entry as it comes in. For different flushing policies please take a look at g3sinks logrotate and LogRotateWithFilters . At shutdown all enqueued logs will be flushed to the sink. At a discovered fatal event (SIGSEGV et.al) all enqueued logs will be flushed to the sink. A programmatically triggered abrupt process exit such as a call to exit(0) will of course not get the enqueued log entries flushed. Similary a bug that does not trigger a fatal signal but a process exit will also not get the enqueued log entries flushed. G3log can catch several fatal crashes and it deals well with RAII exits but magic is so far out of its' reach.","title":"LOG flushing"},{"location":"API/#g3log-and-sink-usage-code-example","text":"Example usage where a logrotate sink (g3sinks) is added. In the example it is shown how the logrotate API is called. The logrotate limit is changed from the default to instead be 10MB. The limit is changed by calling the sink handler which passes the function call through to the actual logrotate sink object. // main.cpp #include <g3log/g3log.hpp> #include <g3log/logworker.h> #include <g3sinks/LogRotate.h> #include <memory> int main(int argc, char**argv) { using namespace g3; std::unique_ptr<LogWorker> logworker{ LogWorker::createLogWorker() }; auto sinkHandle = logworker->addSink(std::make_unique<LogRotate>(), &LogRotate::save); // initialize the logger before it can receive LOG calls initializeLogging(logworker.get()); // You can call in a thread safe manner public functions on the logrotate sink // The call is asynchronously executed on your custom sink. const int k10MBInBytes = 10 * 1024 * 1024; std::future<void> received = sinkHandle->call(&LogRotate::setMaxLogSize, k10MBInBytes); // Run the main part of the application. This can be anything of course, in this example // we'll call it \"RunApplication\". Once this call exits we are in shutdown mode RunApplication(); // If the LogWorker is initialized then at scope exit the g3::shutDownLogging() will be // called automatically. // // This is important since it protects from LOG calls from static or other entities that will go out of // scope at a later time. // // It can also be called manually if for some reason your setup is different then the one highlighted in // this example g3::shutDownLogging(); }","title":"G3log and Sink Usage Code Example"},{"location":"API/#dynamic-message-sizing","text":"The default build uses a fixed size buffer for formatting messages. The size of this buffer is 2048 bytes. If an incoming message results in a formatted message that is greater than 2048 bytes, it will be bound to 2048 bytes and will have the string [...truncated...] appended to the end of the bound message. There are cases where one would like to dynamically change the size at runtime. For example, when debugging payloads for a server, it may be desirable to handle larger message sizes in order to examine the whole payload. Rather than forcing the developer to rebuild the server, dynamic message sizing could be used along with a config file which defines the message size at runtime. This feature supported as a CMake option: CMake option: (default OFF) cmake -DUSE_G3_DYNAMIC_MAX_MESSAGE_SIZE=ON .. The following is an example of changing the size for the message. g3::only_change_at_initialization::setMaxMessageSize(10000);","title":"Dynamic Message Sizing "},{"location":"API/#fatal-handling","text":"The default behaviour for G3log is to catch several fatal events before they force the process to exit. After catching a fatal event a stack dump is generated and all log entries, up to the point of the stack dump are together with the dump flushed to the sink(s).","title":"Fatal handling"},{"location":"API/#linuxnix","text":"The default fatal handling on Linux deals with fatal signals. At the time of writing these signals were SIGABRT, SIGFPE, SIGILL, SIGSEGV, SIGTERM . The Linux fatal handling is handled in crashhandler.hpp and crashhandler_unix.cpp A signal that commonly is associated with voluntarily process exit is SIGINT (ctrl + c) G3log does not deal with it. The fatal signals can be disabled or changed/added . An example of a Linux stackdump as shown in the output from the fatal example g3log-FATAL-sigsegv . ``` * FATAL SIGNAL RECEIVED * \"Received fatal signal: SIGSEGV(11) PID: 6571 ***** SIGNAL SIGSEGV(11) ******* STACKDUMP ******* stack dump [1] ./g3log-FATAL-sigsegv() [0x42a500] stack dump [2] /lib/x86_64-linux-gnu/libpthread.so.0+0x10340 [0x7f83636d5340] stack dump [3] ./g3log-FATAL-sigsegv : example_fatal::tryToKillWithAccessingIllegalPointer(std::unique_ptr<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::default_delete<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >)+0x119 [0x4107b9] stack dump [4] ./g3log-FATAL-sigsegvmain+0xdec [0x40e51c] stack dump [5] /lib/x86_64-linux-gnu/libc.so.6__libc_start_main+0xf5 [0x7f8363321ec5] stack dump [6] ./g3log-FATAL-sigsegv() [0x40ffa2] Exiting after fatal event (FATAL_SIGNAL). Fatal type: SIGSEGV Log content flushed sucessfully to sink \" g3log g3FileSink shutdown at: 16:33:18 ```","title":"Linux/*nix"},{"location":"API/#custom-fatal-handling-override-defaults","text":"By default the fatal signals are defined in https://github.com/KjellKod/g3log/tree/master/src/g3log.cpp as SIGABRT SIGFPE SIGILL SIGSEGV SIGTERM If you want to define your own set of fatal signals, override the default ones, then this can be done as shown in src/g3log/crashhandler.hpp cpp // Example when SIGTERM is skipped due to ZMQ usage g3::overrideSetupSignals({ {SIGABRT, \"SIGABRT\"}, {SIGFPE, \"SIGFPE\"}, {SIGILL, \"SIGILL\"}, {SIGSEGV, \"SIGSEGV\"}});","title":"Custom fatal handling - override defaults"},{"location":"API/#pre-fatal-hook","text":"You can define a custom call back function that will be called before the fatal signal handling re-emits the fatal signal. See src/g3log/g3log.hpp for details. // Example of how to enforce important shutdown cleanup even in the event of a fatal crash: g3::setFatalPreLoggingHook([]{ cleanup(); });","title":"Pre fatal hook"},{"location":"API/#disable-fatal-handling","text":"Fatal signal handling can be disabled with a CMake option: ENABLE_FATAL_SIGNALHANDLING . See Options.cmake for more details","title":"Disable fatal handling"},{"location":"API/#pid1-fatal-signal-recommendations","text":"If you are using g3log on a PID1 process then you absolutely should provide your own signal handling (ref: issue 269 ) as g3log re-emits the fatal signal after it has restored the previous signal handler for that signal. PID1 processed do not shutdown the process for a normal fatal signal so the choice to exit the PID1 process after such a signal must be taken by the coder - not by g3log.","title":"PID1 Fatal Signal Recommendations"},{"location":"API/#windows","text":"Windows fatal handling also deals with fatal signals just like Linux. In addition to fatal signals it also deals with unhandled exceptions, vectored exceptions. Windows fatal handling is handled in crashhandler.hpp , crashhandler_windows.cpp , stacktrace_windows.hpp , stacktrace_windows.cpp An example of a Windows stackdump as shown in the output from the fatal example g3log-FATAL-sigsegv . introduction | detailed information | Configure & Build | API description | Custom log formatting","title":"Windows"},{"location":"API_custom_formatting/","text":"introduction | detailed information | Configure & Build | API description | Custom log formatting Custom LOG formatting Overriding the Default File Sink's file header The default file header can be customized in the default file sink in calling FileSink::overrideLogHeader(std::string); Overriding the Default FileSink's log formatting The default log formatting is defined in LogMessage.hpp static std::string DefaultLogDetailsToString(const LogMessage& msg); Adding thread ID to the log formatting An \"all details\" log formatting function is also defined - this one also adds the \"calling thread's ID\" static std::string FullLogDetailsToString(const LogMessage& msg); Override default sink log formatting For convenience the Default sink has a function for doing exactly this void overrideLogDetails(LogMessage::LogDetailsFunc func); Example code for replacing the default log formatting for \"full details\" formatting (it adds thread ID) auto worker = g3::LogWorker::createLogWorker(); auto handle= worker->addDefaultLogger(argv[0], path_to_log_file); g3::initializeLogging(worker.get()); handle->call(&g3::FileSink::overrideLogDetails, &LogMessage::FullLogDetailsToString); See test_message.cpp for details and testing Example code for overloading the formatting of a custom sink. The log formatting function will be passed into the LogMessage::toString(...) this will override the default log formatting Example namespace { std::string MyCustomFormatting(const LogMessage& msg) { ... how you want it ... } } void MyCustomSink::ReceiveLogEntry(LogMessageMover message) { std::string formatted = message.get().toString(&MyCustomFormatting) << std::flush; } ... ... auto worker = g3::LogWorker::createLogWorker(); auto sinkHandle = worker->addSink(std::make_unique<MyCustomSink>(), &MyCustomSink::ReceiveLogMessage); // ReceiveLogMessage(...) will used the custom formatting function \"MyCustomFormatting(...) introduction | detailed information | Configure & Build | API description | Custom log formatting","title":"API for custom log formatting"},{"location":"API_custom_formatting/#custom-log-formatting","text":"","title":"Custom LOG formatting"},{"location":"API_custom_formatting/#overriding-the-default-file-sinks-file-header","text":"The default file header can be customized in the default file sink in calling FileSink::overrideLogHeader(std::string);","title":"Overriding the Default File Sink's file header"},{"location":"API_custom_formatting/#overriding-the-default-filesinks-log-formatting","text":"The default log formatting is defined in LogMessage.hpp static std::string DefaultLogDetailsToString(const LogMessage& msg);","title":"Overriding the Default FileSink's log formatting"},{"location":"API_custom_formatting/#adding-thread-id-to-the-log-formatting","text":"An \"all details\" log formatting function is also defined - this one also adds the \"calling thread's ID\" static std::string FullLogDetailsToString(const LogMessage& msg);","title":"Adding thread ID to the log formatting"},{"location":"API_custom_formatting/#override-default-sink-log-formatting","text":"For convenience the Default sink has a function for doing exactly this void overrideLogDetails(LogMessage::LogDetailsFunc func); Example code for replacing the default log formatting for \"full details\" formatting (it adds thread ID) auto worker = g3::LogWorker::createLogWorker(); auto handle= worker->addDefaultLogger(argv[0], path_to_log_file); g3::initializeLogging(worker.get()); handle->call(&g3::FileSink::overrideLogDetails, &LogMessage::FullLogDetailsToString); See test_message.cpp for details and testing Example code for overloading the formatting of a custom sink. The log formatting function will be passed into the LogMessage::toString(...) this will override the default log formatting Example namespace { std::string MyCustomFormatting(const LogMessage& msg) { ... how you want it ... } } void MyCustomSink::ReceiveLogEntry(LogMessageMover message) { std::string formatted = message.get().toString(&MyCustomFormatting) << std::flush; } ... ... auto worker = g3::LogWorker::createLogWorker(); auto sinkHandle = worker->addSink(std::make_unique<MyCustomSink>(), &MyCustomSink::ReceiveLogMessage); // ReceiveLogMessage(...) will used the custom formatting function \"MyCustomFormatting(...) introduction | detailed information | Configure & Build | API description | Custom log formatting","title":"Override default sink log formatting"},{"location":"building/","text":"introduction | detailed information | Configure & Build | API description | Custom log formatting Configure, build, package, install and test g3log Example Project with g3log An example project integration of g3log, both statially and dynamically built can be found at g3log_example_integration Building it standalone to try out is as easy as: git clone https://github.com/KjellKod/g3log cd g3log mkdir build cd build Prerequisites Assume you have got your shiny C++14 compiler installed, you also need these tools to build g3log from source: - CMake ( Required ) g3log uses CMake as a one-stop solution for configuring, building, installing, packaging and testing on Windows, Linux and OSX. Git ( Optional but Recommended ) When building g3log it uses git to calculate the software version from the commit history of this repository. If you don't want that, or your setup does not have access to git, or you download g3log source archive from the GitHub Releases page so that you do not have the commit history downloaded, you can instead pass in the version as part of the CMake build arguments. See this issue for more information. cmake -DVERSION=1.3.2 .. Configuration Options g3log provides following CMake options (and default values): $ cmake -LAH # List non-advanced cached variables. See `cmake --help` for more details. ... // Fatal (fatal-crashes/contract) examples ADD_FATAL_EXAMPLE:BOOL=ON // g3log performance test ADD_G3LOG_BENCH_PERFORMANCE:BOOL=OFF // g3log unit tests ADD_G3LOG_UNIT_TEST:BOOL=OFF // Use DBUG logging level instead of DEBUG. // By default DEBUG is the debugging level CHANGE_G3LOG_DEBUG_TO_DBUG:BOOL=OFF // Specifies the build type on single-configuration generators. // Possible values are empty, Debug, Release, RelWithDebInfo, MinSizeRel, \u2026 CMAKE_BUILD_TYPE:STRING= // Install path prefix, prepended onto install directories. // This variable defaults to /usr/local on UNIX // and c:/Program Files/${PROJECT_NAME} on Windows. CMAKE_INSTALL_PREFIX:PATH= // The prefix used in the built package. // On Linux, if this option is not set: // 1) If CMAKE_INSTALL_PREFIX is given, then it will be // set with the value of CMAKE_INSTALL_PREFIX by g3log. // 2) Otherwise, it will be set as /usr/local by g3log. CPACK_PACKAGING_INSTALL_PREFIX:PATH= // Enable Visual Studio break point when receiving a fatal exception. // In __DEBUG mode only DEBUG_BREAK_AT_FATAL_SIGNAL:BOOL=OFF // Vectored exception / crash handling with improved stack trace ENABLE_FATAL_SIGNALHANDLING:BOOL=ON // Vectored exception / crash handling with improved stack trace ENABLE_VECTORED_EXCEPTIONHANDLING:BOOL=ON // iOS version of library. G3_IOS_LIB:BOOL=OFF // Log full filename G3_LOG_FULL_FILENAME:BOOL=OFF // Build shared library G3_SHARED_LIB:BOOL=ON // Build shared runtime library MSVC G3_SHARED_RUNTIME:BOOL=ON // Turn ON/OFF log levels. // An disabled level will not push logs of that level to the sink. // By default dynamic logging is disabled USE_DYNAMIC_LOGGING_LEVELS:BOOL=OFF // Use dynamic memory for message buffer during log capturing USE_G3_DYNAMIC_MAX_MESSAGE_SIZE:BOOL=OFF ... For additional option context and comments please also see Options.cmake If you want to leave everything as it was, then you should: cmake .. You may also specify one or more of those options listed above from the command line. For example, on Windows: cmake .. -G \"Visual Studio 15 2017\" -DG3_SHARED_LIB=OFF -DCMAKE_INSTALL_PREFIX=C:/g3log -DADD_G3LOG_UNIT_TEST=ON -DADD_FATAL_EXAMPLE=OFF will use a Visual Studio 2017 solution generator, build g3log as a static library, headers and libraries will be installed to C:\\g3log when installed from source, enable unit testing, but do not build fatal example. MinGW users on Windows may find they should use a different generator: cmake .. -G \"MinGW Makefiles\" By default, headers and libraries will be installed to /usr/local on Linux when installed from build tree via make install . You may overwrite it by: cmake .. -DCMAKE_INSTALL_PREFIX=/usr This will install g3log to /usr instead of /usr/local . Linux/OSX package maintainers may be interested in the CPACK_PACKAGING_INSTALL_PREFIX . For example: cmake .. -DCPACK_PACKAGING_INSTALL_PREFIX=/usr/local Build Commands Once the configuration is done, you may build g3log with: # Suppose you are still in the `build` directory. I won't repeat it anymore! cmake --build . --config Release You may also build it with a system-specific way. On Linux, OSX and MinGW: make On Windows: msbuild g3log.sln /p:Configuration=Release Windows users can also open the generated Visual Studio solution file and build it happily. Installation Install from source in a CMake way: cmake --build . --target install Linux users may also use: sudo make install You may also create a package first and install g3log with it. See the next section. Packaging A CMake way: cmake --build . --config Release --target package or cpack -C Release if the whole library has been built in the previous step. It will generate a ZIP package on Windows, and a DEB package on Linux. Linux users may also use a Linux way: make package If you want to use a different package generator, you should specify a -G option. On Windows: cpack -C Release -G NSIS;7Z this will create a installable NSIS package and a 7z package. Note: To use the NSIS generator, you should install NSIS first. On Linux: cpack -C Release -G TGZ this will create a .tar.gz archive for you. Once done, you may install or uncompress the package file to the target machine. For example, on Debian or Ubuntu: sudo dpkg -i g3log-<version>-Linux.deb will install the g3log library to CPACK_PACKAGING_INSTALL_PREFIX . Testing By default, tests will not be built. To enable unit testing, you should turn on ADD_G3LOG_UNIT_TEST . Suppose the build process has completed, then you can run the tests with: ctest -C Release or: make test for Linux users. or for a detailed gtest output of all the tests: cd build; ../scripts/runAllTests.sh CMake module g3log comes with a CMake module. Once installed, it can be found under ${CMAKE_INSTALL_PREFIX}/lib/cmake/g3log . Users can use g3log in a CMake-based project this way: find_package(g3log CONFIG REQUIRED) target_link_libraries(main PRIVATE g3log) To make sure that CMake can find g3log, you also need to tell CMake where to search for it: cmake .. -DCMAKE_PREFIX_PATH=<g3log's install prefix> Build Options The build options are defined in the file Options.cmake build options are generated and saved to a header file. This avoid having to set the define options in the client source code introduction | detailed information | Configure & Build | API description | Custom log formatting","title":"Configure, Build, Package, Install and Test"},{"location":"building/#configure-build-package-install-and-test-g3log","text":"","title":"Configure, build, package, install and test g3log"},{"location":"building/#example-project-with-g3log","text":"An example project integration of g3log, both statially and dynamically built can be found at g3log_example_integration","title":"Example Project with g3log"},{"location":"building/#building-it-standalone-to-try-out-is-as-easy-as","text":"git clone https://github.com/KjellKod/g3log cd g3log mkdir build cd build","title":"Building it standalone to try out is as easy as:"},{"location":"building/#prerequisites","text":"Assume you have got your shiny C++14 compiler installed, you also need these tools to build g3log from source: - CMake ( Required ) g3log uses CMake as a one-stop solution for configuring, building, installing, packaging and testing on Windows, Linux and OSX. Git ( Optional but Recommended ) When building g3log it uses git to calculate the software version from the commit history of this repository. If you don't want that, or your setup does not have access to git, or you download g3log source archive from the GitHub Releases page so that you do not have the commit history downloaded, you can instead pass in the version as part of the CMake build arguments. See this issue for more information. cmake -DVERSION=1.3.2 ..","title":"Prerequisites"},{"location":"building/#configuration-options","text":"g3log provides following CMake options (and default values): $ cmake -LAH # List non-advanced cached variables. See `cmake --help` for more details. ... // Fatal (fatal-crashes/contract) examples ADD_FATAL_EXAMPLE:BOOL=ON // g3log performance test ADD_G3LOG_BENCH_PERFORMANCE:BOOL=OFF // g3log unit tests ADD_G3LOG_UNIT_TEST:BOOL=OFF // Use DBUG logging level instead of DEBUG. // By default DEBUG is the debugging level CHANGE_G3LOG_DEBUG_TO_DBUG:BOOL=OFF // Specifies the build type on single-configuration generators. // Possible values are empty, Debug, Release, RelWithDebInfo, MinSizeRel, \u2026 CMAKE_BUILD_TYPE:STRING= // Install path prefix, prepended onto install directories. // This variable defaults to /usr/local on UNIX // and c:/Program Files/${PROJECT_NAME} on Windows. CMAKE_INSTALL_PREFIX:PATH= // The prefix used in the built package. // On Linux, if this option is not set: // 1) If CMAKE_INSTALL_PREFIX is given, then it will be // set with the value of CMAKE_INSTALL_PREFIX by g3log. // 2) Otherwise, it will be set as /usr/local by g3log. CPACK_PACKAGING_INSTALL_PREFIX:PATH= // Enable Visual Studio break point when receiving a fatal exception. // In __DEBUG mode only DEBUG_BREAK_AT_FATAL_SIGNAL:BOOL=OFF // Vectored exception / crash handling with improved stack trace ENABLE_FATAL_SIGNALHANDLING:BOOL=ON // Vectored exception / crash handling with improved stack trace ENABLE_VECTORED_EXCEPTIONHANDLING:BOOL=ON // iOS version of library. G3_IOS_LIB:BOOL=OFF // Log full filename G3_LOG_FULL_FILENAME:BOOL=OFF // Build shared library G3_SHARED_LIB:BOOL=ON // Build shared runtime library MSVC G3_SHARED_RUNTIME:BOOL=ON // Turn ON/OFF log levels. // An disabled level will not push logs of that level to the sink. // By default dynamic logging is disabled USE_DYNAMIC_LOGGING_LEVELS:BOOL=OFF // Use dynamic memory for message buffer during log capturing USE_G3_DYNAMIC_MAX_MESSAGE_SIZE:BOOL=OFF ... For additional option context and comments please also see Options.cmake If you want to leave everything as it was, then you should: cmake .. You may also specify one or more of those options listed above from the command line. For example, on Windows: cmake .. -G \"Visual Studio 15 2017\" -DG3_SHARED_LIB=OFF -DCMAKE_INSTALL_PREFIX=C:/g3log -DADD_G3LOG_UNIT_TEST=ON -DADD_FATAL_EXAMPLE=OFF will use a Visual Studio 2017 solution generator, build g3log as a static library, headers and libraries will be installed to C:\\g3log when installed from source, enable unit testing, but do not build fatal example. MinGW users on Windows may find they should use a different generator: cmake .. -G \"MinGW Makefiles\" By default, headers and libraries will be installed to /usr/local on Linux when installed from build tree via make install . You may overwrite it by: cmake .. -DCMAKE_INSTALL_PREFIX=/usr This will install g3log to /usr instead of /usr/local . Linux/OSX package maintainers may be interested in the CPACK_PACKAGING_INSTALL_PREFIX . For example: cmake .. -DCPACK_PACKAGING_INSTALL_PREFIX=/usr/local","title":"Configuration Options"},{"location":"building/#build-commands","text":"Once the configuration is done, you may build g3log with: # Suppose you are still in the `build` directory. I won't repeat it anymore! cmake --build . --config Release You may also build it with a system-specific way. On Linux, OSX and MinGW: make On Windows: msbuild g3log.sln /p:Configuration=Release Windows users can also open the generated Visual Studio solution file and build it happily.","title":"Build Commands"},{"location":"building/#installation","text":"Install from source in a CMake way: cmake --build . --target install Linux users may also use: sudo make install You may also create a package first and install g3log with it. See the next section.","title":"Installation"},{"location":"building/#packaging","text":"A CMake way: cmake --build . --config Release --target package or cpack -C Release if the whole library has been built in the previous step. It will generate a ZIP package on Windows, and a DEB package on Linux. Linux users may also use a Linux way: make package If you want to use a different package generator, you should specify a -G option. On Windows: cpack -C Release -G NSIS;7Z this will create a installable NSIS package and a 7z package. Note: To use the NSIS generator, you should install NSIS first. On Linux: cpack -C Release -G TGZ this will create a .tar.gz archive for you. Once done, you may install or uncompress the package file to the target machine. For example, on Debian or Ubuntu: sudo dpkg -i g3log-<version>-Linux.deb will install the g3log library to CPACK_PACKAGING_INSTALL_PREFIX .","title":"Packaging"},{"location":"building/#testing","text":"By default, tests will not be built. To enable unit testing, you should turn on ADD_G3LOG_UNIT_TEST . Suppose the build process has completed, then you can run the tests with: ctest -C Release or: make test for Linux users. or for a detailed gtest output of all the tests: cd build; ../scripts/runAllTests.sh","title":"Testing"},{"location":"building/#cmake-module","text":"g3log comes with a CMake module. Once installed, it can be found under ${CMAKE_INSTALL_PREFIX}/lib/cmake/g3log . Users can use g3log in a CMake-based project this way: find_package(g3log CONFIG REQUIRED) target_link_libraries(main PRIVATE g3log) To make sure that CMake can find g3log, you also need to tell CMake where to search for it: cmake .. -DCMAKE_PREFIX_PATH=<g3log's install prefix>","title":"CMake module"},{"location":"building/#build-options","text":"The build options are defined in the file Options.cmake build options are generated and saved to a header file. This avoid having to set the define options in the client source code introduction | detailed information | Configure & Build | API description | Custom log formatting","title":"Build Options"},{"location":"contributing/","text":"Information for contributing to g3log License LICENSE Contributing CONTRIBUTING.md Code of conduct CODE_OF_CONDUCT.md Pull request template PULL_REQUEST_TEMPLATE.md","title":"License and contribution"},{"location":"contributing/#information-for-contributing-to-g3log","text":"","title":"Information for contributing to g3log"},{"location":"contributing/#license","text":"LICENSE","title":"License"},{"location":"contributing/#contributing","text":"CONTRIBUTING.md","title":"Contributing"},{"location":"contributing/#code-of-conduct","text":"CODE_OF_CONDUCT.md","title":"Code of conduct"},{"location":"contributing/#pull-request-template","text":"PULL_REQUEST_TEMPLATE.md","title":"Pull request template"},{"location":"g3log/","text":"introduction | detailed information | Configure & Build | API description | Custom log formatting How to use g3log G3log is an asynchronous logger with dynamic sinks Example USAGE Optional to use either streaming or printf-like syntax LOG(INFO) << \"streaming API is as easy as ABC or \" << 123; LOGF(WARNING, \"Printf-style syntax is also %s\", \"available\"); What g3Log is G3log is the acting name for the third version of g2log and it stands for g3log with dynamic sinks G3log is an asynchronous, \"crash-safe\" logger. You can read more about it here [g2log version] You can choose to use the default log receiver which saves all LOG calls to file, or you can choose to use your own custom made log receiver(s), or both, or as many sinks as you need. Conditional logging int less = 1; int more = 2 LOG_IF(INFO, (less<more)) <<\"If [true], then this text will be logged\"; // or with printf-like syntax LOGF_IF(INFO, (less<more), \"if %d<%d then this text will be logged\", less,more); Design-by-Contract CHECK(false) will trigger a \"fatal\" message. It will be logged, and then the application will exit. CHECK(less != more); // not FATAL CHECK(less > more) << \"CHECK(false) triggers a FATAL message\"; Detailed API documentation Please look at API.md for detailed API documentation Benefits you get when using g3log Easy to use, clean syntax and a blazing fast logger. All the slow log I/O disk access is done in a background thread. This ensures that the LOG caller can immediately continue with other tasks and do not have to wait for the LOG call to finish. G3log provides logging, Design-by-Contract [#CHECK], and flush of log to file at shutdown. Buffered logs will be written to the sink before the application shuts down. It is thread safe, so using it from multiple threads is completely fine. It is CRASH SAFE . It will save the made logs to the sink before it shuts down. The logger will catch certain fatal events (Linux/OSX: signals, Windows: fatal OS exceptions and signals) , so if your application crashes due to, say a segmentation fault, SIGSEGV , it will log and save the crash and all previously buffered log entries before exiting. It is cross platform. Tested and used by me or by clients on OSX, Windows, Ubuntu, CentOS G3log and G2log are used worldwide in commercial products as well as hobby projects. G2log was introduced in early 2011 and is now retired. The code is given for free as public domain. This gives the option to change, use, and do whatever with it, no strings attached. g3log : is made to facilitate easy adding of custom log receivers. Its tested on at least the following platforms with Linux (Clang/gcc), Windows (mingw, visual studio) and OSX . My recommendation is to go with g3log if you have full C++14 support (C++11 support up to version: https://github.com/KjellKod/g3log/releases/tag/1.3.1). G3log with sinks Sinks are receivers of LOG calls. G3log comes with a default sink ( the same as g3log uses ) that can be used to save log to file. A sink can be of any class type without restrictions as long as it can either receive a LOG message as a std::string or as a g3::LogMessageMover . The std::string comes pre-formatted. The g3::LogMessageMover is a wrapped struct that contains the raw data for custom handling in your own sink. A sink is owned by the g3log and is added to the logger inside a std::unique_ptr . The sink can be called though its public API through a handler which will asynchronously forward the call to the receiving sink. It is crazy simple to create a custom sink . This example show what is needed to make a custom sink that is using custom log formatting but only using that for adding color to the default log formatting. The sink forwards the colored log to cout // in file Customsink.hpp #pragma once #include <string> #include <iostream> #include <g3log/logmessage.hpp> struct CustomSink { // Linux xterm color // http://stackoverflow.com/questions/2616906/how-do-i-output-coloured-text-to-a-linux-terminal enum FG_Color {YELLOW = 33, RED = 31, GREEN=32, WHITE = 97}; FG_Color GetColor(const LEVELS level) const { if (level.value == WARNING.value) { return YELLOW; } if (level.value == DEBUG.value) { return GREEN; } if (g3::internal::wasFatal(level)) { return RED; } return WHITE; } void ReceiveLogMessage(g3::LogMessageMover logEntry) { auto level = logEntry.get()._level; auto color = GetColor(level); std::cout << \"\\033[\" << color << \"m\" << logEntry.get().toString() << \"\\033[m\" << std::endl; } }; // in main.cpp, main() function auto sinkHandle = logworker->addSink(std::make_unique<CustomSink>(), &CustomSink::ReceiveLogMessage); Adding and Removing Sinks You can safely remove and add sinks during the running of your program. Keep in mind Initialization of the logger should happen before you have started any other threads that may call the logger. Destruction of the logger (RAII concept) should happen AFTER shutdown of other threads that are calling the logger. Adding Sinks auto sinkHandle1 = logworker->addSink(std::make_unique<CustomSink>(), &CustomSink::ReceiveLogMessage); auto sinkHandle2 = logworker->addDefaultLogger(argv[0], path_to_log_file); logworker->removeSink(std::move(sinkHandle1)); // this will in a thread-safe manner remove the sinkHandle1 logworker->removeAllSinks(); // this will in a thread-safe manner remove any sinks. More sinks can be found in the repository github.com/KjellKod/g3sinks . Code Examples Example usage where a custom sink is added. A function is called though the sink handler to the actual sink object. // main.cpp #include <g3log/g3log.hpp> #include <g3log/logworker.hpp> #include <memory> #include \"CustomSink.h\" int main(int argc, char**argv) { using namespace g3; std::unique_ptr<LogWorker> logworker{ LogWorker::createLogWorker() }; auto sinkHandle = logworker->addSink(std::make_unique<CustomSink>(), &CustomSink::ReceiveLogMessage); // initialize the logger before it can receive LOG calls initializeLogging(logworker.get()); LOG(WARNING) << \"This log call, may or may not happend before\" << \"the sinkHandle->call below\"; // You can call in a thread safe manner public functions on your sink // The call is asynchronously executed on your custom sink. std::future<void> received = sinkHandle->call(&CustomSink::Foo, param1, param2); // If the LogWorker is initialized then at scope exit the g3::internal::shutDownLogging() will be called. // This is important since it protects from LOG calls from static or other entities that will go out of // scope at a later time. // // It can also be called manually: g3::internal::shutDownLogging(); } // some_file.cpp : To show how easy it is to get the logger to work // in other parts of your software #include <g3log/g3log.hpp> void SomeFunction() { ... LOG(INFO) << \"Hello World\"; } Example usage where a the default file logger is used and a custom sink is added // main.cpp #include <g3log/g3log.hpp> #include <g3log/logworker.hpp> #include <memory> #include \"CustomSink.h\" int main(int argc, char**argv) { using namespace g3; auto worker = LogWorker::createLogWorker(); auto defaultHandler = worker->addDefaultLogger(argv[0], path_to_log_file); // logger is initialized g3::initializeLogging(worker.get()); LOG(DEBUG) << \"Make log call, then add another sink\"; worker->addSink(std::make_unique<CustomSink>(), &CustomSink::ReceiveLogMessage); ... } introduction | detailed information | Configure & Build | API description | Custom log formatting","title":"G3log usage"},{"location":"g3log/#how-to-use-g3log","text":"G3log is an asynchronous logger with dynamic sinks","title":"How to use g3log"},{"location":"g3log/#example-usage","text":"","title":"Example USAGE"},{"location":"g3log/#optional-to-use-either-streaming-or-printf-like-syntax","text":"LOG(INFO) << \"streaming API is as easy as ABC or \" << 123; LOGF(WARNING, \"Printf-style syntax is also %s\", \"available\");","title":"Optional to use either streaming or printf-like syntax"},{"location":"g3log/#what-g3log-is","text":"G3log is the acting name for the third version of g2log and it stands for g3log with dynamic sinks G3log is an asynchronous, \"crash-safe\" logger. You can read more about it here [g2log version] You can choose to use the default log receiver which saves all LOG calls to file, or you can choose to use your own custom made log receiver(s), or both, or as many sinks as you need.","title":"What g3Log is"},{"location":"g3log/#conditional-logging","text":"int less = 1; int more = 2 LOG_IF(INFO, (less<more)) <<\"If [true], then this text will be logged\"; // or with printf-like syntax LOGF_IF(INFO, (less<more), \"if %d<%d then this text will be logged\", less,more);","title":"Conditional logging"},{"location":"g3log/#design-by-contract","text":"CHECK(false) will trigger a \"fatal\" message. It will be logged, and then the application will exit. CHECK(less != more); // not FATAL CHECK(less > more) << \"CHECK(false) triggers a FATAL message\";","title":"Design-by-Contract"},{"location":"g3log/#detailed-api-documentation","text":"Please look at API.md for detailed API documentation","title":"Detailed API documentation"},{"location":"g3log/#benefits-you-get-when-using-g3log","text":"Easy to use, clean syntax and a blazing fast logger. All the slow log I/O disk access is done in a background thread. This ensures that the LOG caller can immediately continue with other tasks and do not have to wait for the LOG call to finish. G3log provides logging, Design-by-Contract [#CHECK], and flush of log to file at shutdown. Buffered logs will be written to the sink before the application shuts down. It is thread safe, so using it from multiple threads is completely fine. It is CRASH SAFE . It will save the made logs to the sink before it shuts down. The logger will catch certain fatal events (Linux/OSX: signals, Windows: fatal OS exceptions and signals) , so if your application crashes due to, say a segmentation fault, SIGSEGV , it will log and save the crash and all previously buffered log entries before exiting. It is cross platform. Tested and used by me or by clients on OSX, Windows, Ubuntu, CentOS G3log and G2log are used worldwide in commercial products as well as hobby projects. G2log was introduced in early 2011 and is now retired. The code is given for free as public domain. This gives the option to change, use, and do whatever with it, no strings attached. g3log : is made to facilitate easy adding of custom log receivers. Its tested on at least the following platforms with Linux (Clang/gcc), Windows (mingw, visual studio) and OSX . My recommendation is to go with g3log if you have full C++14 support (C++11 support up to version: https://github.com/KjellKod/g3log/releases/tag/1.3.1).","title":"Benefits you get when using g3log"},{"location":"g3log/#g3log-with-sinks","text":"Sinks are receivers of LOG calls. G3log comes with a default sink ( the same as g3log uses ) that can be used to save log to file. A sink can be of any class type without restrictions as long as it can either receive a LOG message as a std::string or as a g3::LogMessageMover . The std::string comes pre-formatted. The g3::LogMessageMover is a wrapped struct that contains the raw data for custom handling in your own sink. A sink is owned by the g3log and is added to the logger inside a std::unique_ptr . The sink can be called though its public API through a handler which will asynchronously forward the call to the receiving sink. It is crazy simple to create a custom sink . This example show what is needed to make a custom sink that is using custom log formatting but only using that for adding color to the default log formatting. The sink forwards the colored log to cout // in file Customsink.hpp #pragma once #include <string> #include <iostream> #include <g3log/logmessage.hpp> struct CustomSink { // Linux xterm color // http://stackoverflow.com/questions/2616906/how-do-i-output-coloured-text-to-a-linux-terminal enum FG_Color {YELLOW = 33, RED = 31, GREEN=32, WHITE = 97}; FG_Color GetColor(const LEVELS level) const { if (level.value == WARNING.value) { return YELLOW; } if (level.value == DEBUG.value) { return GREEN; } if (g3::internal::wasFatal(level)) { return RED; } return WHITE; } void ReceiveLogMessage(g3::LogMessageMover logEntry) { auto level = logEntry.get()._level; auto color = GetColor(level); std::cout << \"\\033[\" << color << \"m\" << logEntry.get().toString() << \"\\033[m\" << std::endl; } }; // in main.cpp, main() function auto sinkHandle = logworker->addSink(std::make_unique<CustomSink>(), &CustomSink::ReceiveLogMessage);","title":"G3log with sinks"},{"location":"g3log/#adding-and-removing-sinks","text":"You can safely remove and add sinks during the running of your program. Keep in mind Initialization of the logger should happen before you have started any other threads that may call the logger. Destruction of the logger (RAII concept) should happen AFTER shutdown of other threads that are calling the logger. Adding Sinks auto sinkHandle1 = logworker->addSink(std::make_unique<CustomSink>(), &CustomSink::ReceiveLogMessage); auto sinkHandle2 = logworker->addDefaultLogger(argv[0], path_to_log_file); logworker->removeSink(std::move(sinkHandle1)); // this will in a thread-safe manner remove the sinkHandle1 logworker->removeAllSinks(); // this will in a thread-safe manner remove any sinks. More sinks can be found in the repository github.com/KjellKod/g3sinks .","title":"Adding and Removing Sinks"},{"location":"g3log/#code-examples","text":"Example usage where a custom sink is added. A function is called though the sink handler to the actual sink object. // main.cpp #include <g3log/g3log.hpp> #include <g3log/logworker.hpp> #include <memory> #include \"CustomSink.h\" int main(int argc, char**argv) { using namespace g3; std::unique_ptr<LogWorker> logworker{ LogWorker::createLogWorker() }; auto sinkHandle = logworker->addSink(std::make_unique<CustomSink>(), &CustomSink::ReceiveLogMessage); // initialize the logger before it can receive LOG calls initializeLogging(logworker.get()); LOG(WARNING) << \"This log call, may or may not happend before\" << \"the sinkHandle->call below\"; // You can call in a thread safe manner public functions on your sink // The call is asynchronously executed on your custom sink. std::future<void> received = sinkHandle->call(&CustomSink::Foo, param1, param2); // If the LogWorker is initialized then at scope exit the g3::internal::shutDownLogging() will be called. // This is important since it protects from LOG calls from static or other entities that will go out of // scope at a later time. // // It can also be called manually: g3::internal::shutDownLogging(); } // some_file.cpp : To show how easy it is to get the logger to work // in other parts of your software #include <g3log/g3log.hpp> void SomeFunction() { ... LOG(INFO) << \"Hello World\"; } Example usage where a the default file logger is used and a custom sink is added // main.cpp #include <g3log/g3log.hpp> #include <g3log/logworker.hpp> #include <memory> #include \"CustomSink.h\" int main(int argc, char**argv) { using namespace g3; auto worker = LogWorker::createLogWorker(); auto defaultHandler = worker->addDefaultLogger(argv[0], path_to_log_file); // logger is initialized g3::initializeLogging(worker.get()); LOG(DEBUG) << \"Make log call, then add another sink\"; worker->addSink(std::make_unique<CustomSink>(), &CustomSink::ReceiveLogMessage); ... } introduction | detailed information | Configure & Build | API description | Custom log formatting","title":"Code Examples"}]}